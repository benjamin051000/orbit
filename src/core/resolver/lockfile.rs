use std::{str::FromStr, path::{PathBuf}};
use toml_edit::Document;
use crate::{util::{sha256::Sha256Hash, anyerror::{AnyError, Fault}}, core::{pkgid::PkgId, version::Version, config::FromToml}};

/// Determines if a new .lock file needs to be generated.
/// 
/// Returning `true` signifies the .lock file is up-to-date. Assumes the function
/// is called from the ip's root directory.
/// 
/// Conditions for re-solving:
/// - Orbit.lock does not exist at root IP directory level
/// - Orbit.lock is missing current IP's checksum
/// - Orbit.lock has an outdated checksum
pub fn is_locked(target: &PkgId, version: &Version, file: &str) -> bool {
    let lock_path = PathBuf::from(file);
    // check that the file exists
    if lock_path.exists() == false || lock_path.is_file() == false {
        return false
    }

    // look up the checksum in the .lock file to compare
    let lock = match LockFile::from_file(&lock_path) {
        Ok(l) => l,
        Err(_) => return false,
    };
    // verify the ip is in the .lock file
    let entry = match lock.get(target, version) {
        Some(it) => it,
        None => return false,
    };
    // compute the checksum on the current ip
    let ip_files = crate::core::fileset::gather_current_files(&{ if let Some(p) = lock_path.parent() { p.to_path_buf() } else { PathBuf::from(".") }});
    let checksum = crate::util::checksum::checksum(&ip_files);
    println!("{}", checksum);
    println!("{}", entry.get_sum());
    // verify the checksums match
    &checksum == entry.get_sum()
}

#[derive(Debug)]
pub struct LockFile(Vec<LockEntry>);

impl FromToml for LockFile {
    type Err = Fault;
    
    fn from_toml(table: &toml_edit::Table) -> Result<Self, Self::Err> where Self: Sized {
        let mut inner = Vec::new();
        // take array as as tables
        if let Some(item) = table.get("ip") {
            match item.as_array_of_tables() {
                // parse each table entry into a `LockEntry` struct
                Some(arr) => {
                    for tbl in arr {
                        inner.push(LockEntry::from_toml(tbl)?);
                    }
                }
                None => {
                    return Err(AnyError(format!("expects 'ip' to be an array of tables")))?
                }
            }
        }
        Ok(Self(inner))
    }
}

impl LockFile {
    pub fn from_file(file: &PathBuf) -> Result<Self, Fault> {
        // open file
        let contents = std::fs::read_to_string(&file)?;
        // parse toml syntax
        Ok(Self::from_toml(contents.parse::<Document>()?.as_table())?)
    }

    pub fn get(&self, target: &PkgId, version: &Version) -> Option<&LockEntry> {
        self.0.iter().find(|&f| &f.name == target && &f.version == version )
    }

    fn len(&self) -> usize {
        self.0.len()
    }
}

#[derive(Debug, PartialEq)]
pub struct LockEntry {
    name: PkgId,
    version: Version,
    sum: Sha256Hash
}

impl LockEntry {
    pub fn get_sum(&self) -> &Sha256Hash {
        &self.sum
    }
}

impl FromToml for LockEntry {
    type Err = Fault; 

    fn from_toml(table: &toml_edit::Table) -> Result<Self, Self::Err> where Self: Sized {
        Ok(Self {
            name: PkgId::from_str(table.get("name").unwrap().as_str().unwrap())?,
            version: Version::from_str(table.get("version").unwrap().as_str().unwrap())?,
            sum: Sha256Hash::from_str(table.get("sum").unwrap().as_str().unwrap())?,
        })
    }
}

#[cfg(test)]
mod test {
    use toml_edit::Document;
    use super::*;

    #[test]
    fn from_toml() {
        let toml = r#"
# This file is automatically generated by Orbit.
# It is not intended for manual editing.

[[ip]]
name = "ks-tech.rary.gates"
version = "0.1.0"
sum = "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
source = "git.url1"

[[ip]]
name = "ks-tech.util.toolbox"
version = "1.2.3"
sum = "f3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
source = "git.url2"

"#;
        let lock = LockFile::from_toml(toml.parse::<Document>().unwrap().as_table()).unwrap();
        assert_eq!(lock.len(), 2);
    }

    #[test]
    fn check_lock() {
        let file = "./test/data/projects/project-a/".to_owned() + IP_LOCK_FILE;
        assert_eq!(is_locked(
            &PkgId::new()
                .vendor("ks-tech").unwrap()
                .library("rary").unwrap()
                .name("project-a").unwrap(), 
            &Version::new().major(0).minor(2).patch(0),
        &file), true);
    }
}

pub const IP_LOCK_FILE: &str = "Orbit.lock";